#!/usr/bin/env bash

# @describe Discord Token Validator - Extract and validate Discord tokens from files
# @arg command "Command to run (validate, extract, check)" [string]
# @arg path "File or directory path to search for tokens" [string] @default "."
# @option -t --token "Single token to validate directly" [string]
# @option -o --output "Output directory for valid tokens" [string] @default "."
# @option -f --format "Output format for valid tokens (json, txt, csv)" [string] @default "json"
# @flag   -r --recursive "Search recursively in directories"
# @flag   -s --silent "Suppress loading animations"
# @flag   -j --json "Output results as JSON"
# @flag   -q --quiet "Suppress colored output"
# @flag   -n --no-save "Don't save valid tokens to files"
# @meta require-tools curl,rg,jq

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Discord Token Validator - Extract and validate Discord tokens from files

USAGE: fdt [OPTIONS] [COMMAND] [PATH]

ARGS:
  [COMMAND]  "Command to run (validate, extract, check)" [string]
  [PATH]     "File or directory path to search for tokens" [string] @default "."

OPTIONS:
  -t, --token <TOKEN>    "Single token to validate directly" [string]
  -o, --output <OUTPUT>  "Output directory for valid tokens" [string] @default "."
  -f, --format <FORMAT>  "Output format for valid tokens (json, txt, csv)" [string] @default "json"
  -r, --recursive        "Search recursively in directories"
  -s, --silent           "Suppress loading animations"
  -j, --json             "Output results as JSON"
  -q, --quiet            "Suppress colored output"
  -n, --no-save          "Don't save valid tokens to files"
  -h, --help             Print help
  -V, --version          Print version
EOF
    exit
}

_argc_version() {
    echo fdt 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --token | -t)
            _argc_take_args "--token <TOKEN>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_token:-}" ]]; then
                argc_token="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--token\` cannot be used multiple times"
            fi
            ;;
        --output | -o)
            _argc_take_args "--output <OUTPUT>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_output:-}" ]]; then
                argc_output="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--output\` cannot be used multiple times"
            fi
            ;;
        --format | -f)
            _argc_take_args "--format <FORMAT>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_format:-}" ]]; then
                argc_format="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--format\` cannot be used multiple times"
            fi
            ;;
        --recursive | -r)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--recursive\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_recursive:-}" ]]; then
                _argc_die "error: the argument \`--recursive\` cannot be used multiple times"
            else
                argc_recursive=1
            fi
            ;;
        --silent | -s)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--silent\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_silent:-}" ]]; then
                _argc_die "error: the argument \`--silent\` cannot be used multiple times"
            else
                argc_silent=1
            fi
            ;;
        --json | -j)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--json\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_json:-}" ]]; then
                _argc_die "error: the argument \`--json\` cannot be used multiple times"
            else
                argc_json=1
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        --no-save | -n)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--no-save\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_no_save:-}" ]]; then
                _argc_die "error: the argument \`--no-save\` cannot be used multiple times"
            else
                argc_no_save=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(curl rg jq)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_command="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[1]:-}"
        if [[ -n "$values_index" ]]; then
            argc_path="${argc__positionals[values_index]}"
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

# Setup colors
setup_colors() {
  if [ "$argc_quiet" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" blue="" green="" yellow="" red="" cyan="" magenta=""
  else
    bold=$(tput bold) reset=$(tput sgr0) blue=$(tput setaf 4) green=$(tput setaf 2)
    yellow=$(tput setaf 3) red=$(tput setaf 1) cyan=$(tput setaf 6) magenta=$(tput setaf 5)
  fi
}
setup_colors

LOADING_CHARS="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"

show_loading() {
    local token="$1"
    local pid="$2"
    local counter=0

    [ "$argc_silent" = 1 ] && return

    while kill -0 $pid 2>/dev/null; do
        char=${LOADING_CHARS:$((counter % ${#LOADING_CHARS})):1}
        printf "\r${blue}[${char}]${reset} Checking: ${token:0:20}..."
        counter=$((counter + 1))
        sleep 0.1
    done
}

validate_token() {
    local token="$1"
    local response

    response=$(curl -s -H "Authorization: $token" https://discord.com/api/v10/users/@me 2>/dev/null)

    if echo "$response" | grep -q '"id"'; then
        echo "$response"
        return 0
    else
        return 1
    fi
}

extract_tokens() {
    local search_path="$1"
    local temp_tokens=$(mktemp)

    if [ ! -e "$search_path" ]; then
        printf "${red}Error:${reset} Path '%s' does not exist\n" "$search_path" >&2
        return 1
    fi

    local rg_args="-oe"
    [ "$argc_recursive" = 1 ] && rg_args="$rg_args -r"

    # Discord token regex patterns
    local token_pattern='\b[A-Za-z0-9_-]{24}\.[A-Za-z0-9_-]{6}\.[A-Za-z0-9_-]{27}\b|\b[A-Za-z0-9_-]{24}\.[A-Za-z0-9_-]{6}\.[A-Za-z0-9_-]{38}\b'

    if [ -d "$search_path" ]; then
        rg $rg_args "$token_pattern" "$search_path" --no-filename --no-line-number 2>/dev/null | sort -u > "$temp_tokens"
    elif [ -f "$search_path" ]; then
        rg $rg_args "$token_pattern" "$search_path" --no-filename --no-line-number 2>/dev/null | sort -u > "$temp_tokens"
    else
        printf "${red}Error:${reset} Invalid path type\n" >&2
        rm "$temp_tokens"
        return 1
    fi

    echo "$temp_tokens"
}

save_valid_token() {
    local token="$1"
    local response="$2"
    local timestamp=$(date +%s)
    local filename


    case "$argc_format" in
        json)
            filename="${argc_output}/valid_token_${timestamp}.json"
            echo "$response" | jq . > "$filename"
            ;;
        txt)
            filename="${argc_output}/valid_token_${timestamp}.txt"
            echo "$token" > "$filename"
            ;;
        csv)
            filename="${argc_output}/valid_tokens.csv"
            if [ ! -f "$filename" ]; then
                echo "token,username,user_id,timestamp" > "$filename"
            fi
            local username=$(echo "$response" | jq -r '.username // "N/A"')
            local user_id=$(echo "$response" | jq -r '.id // "N/A"')
            echo "$token,$username,$user_id,$(date -Iseconds)" >> "$filename"
            ;;
    esac

    printf "    ${green}Token saved to: %s${reset}\n" "$filename"
}

format_results() {
    local total="$1"
    local valid="$2"
    local invalid="$3"
    local results="$4"

    if [ "$argc_json" = 1 ]; then
        jq -n \
            --arg total "$total" \
            --arg valid "$valid" \
            --arg invalid "$invalid" \
            --argjson results "$results" \
            '{
                total_tokens: ($total | tonumber),
                valid_tokens: ($valid | tonumber),
                invalid_tokens: ($invalid | tonumber),
                results: $results
            }'
    else
        printf "\n${bold}${blue}Validation Complete${reset}\n"
        printf "${bold}${blue}==================${reset}\n"
        printf "${bold}Total tokens checked:${reset} %s\n" "$total"
        printf "${bold}Valid tokens found:${reset} ${green}%s${reset}\n" "$valid"
        printf "${bold}Invalid tokens:${reset} ${red}%s${reset}\n" "$invalid"

        if [ "$valid" -gt 0 ]; then
            printf "\n${green}Valid tokens have been saved to %s format${reset}\n" "$argc_format"
        fi
    fi
}

show_help() {
    echo "${bold}Discord Token Validator${reset}"
    echo ""
    echo "${bold}Commands:${reset}"
    echo "  ${cyan}validate${reset}     Extract and validate tokens from files/directories"
    echo "  ${cyan}extract${reset}      Extract tokens without validation"
    echo "  ${cyan}check${reset}        Validate a single token"
    echo ""
    echo "${bold}Examples:${reset}"
    echo "  ${green}$(basename "$0") validate .${reset}                    # Validate tokens in current directory"
    echo "  ${green}$(basename "$0") validate /path/to/logs --recursive${reset} # Recursive search"
    echo "  ${green}$(basename "$0") check --token 'TOKEN_HERE'${reset}     # Check single token"
    echo "  ${green}$(basename "$0") extract ./logs --format csv${reset}    # Extract to CSV format"
    echo ""
    echo "${bold}Options:${reset}"
    echo "  ${yellow}-t, --token${reset}      Single token to validate"
    echo "  ${yellow}-o, --output${reset}     Output directory for results"
    echo "  ${yellow}-f, --format${reset}     Output format (json, txt, csv)"
    echo "  ${yellow}-r, --recursive${reset}  Search recursively"
    echo "  ${yellow}-s, --silent${reset}     Suppress loading animations"
    echo "  ${yellow}-j, --json${reset}       JSON output format"
    echo "  ${yellow}-n, --no-save${reset}    Don't save valid tokens"
}

cmd_validate() {
    local search_path="${argc_path:-.}"
    local temp_tokens
    local total_tokens=0
    local valid_tokens=0
    local results="[]"

    [ "$argc_json" != 1 ] && printf "${bold}${blue}Discord Token Validator${reset}\n"
    [ "$argc_json" != 1 ] && printf "${bold}${blue}=======================${reset}\n\n"

    # Extract tokens
    [ "$argc_json" != 1 ] && printf "${blue}Extracting tokens from: %s${reset}\n" "$search_path"

    temp_tokens=$(extract_tokens "$search_path")
    [ $? -ne 0 ] && exit 1

    total_tokens=$(wc -l < "$temp_tokens")

    if [ "$total_tokens" -eq 0 ]; then
        [ "$argc_json" != 1 ] && printf "${red}No Discord tokens found.${reset}\n"
        rm "$temp_tokens"
        [ "$argc_json" = 1 ] && echo '{"total_tokens": 0, "valid_tokens": 0, "invalid_tokens": 0, "results": []}'
        exit 0
    fi

    [ "$argc_json" != 1 ] && printf "${blue}Found %s unique tokens. Starting validation...${reset}\n\n" "$total_tokens"

    # Process each token
    while read -r token; do
        [ -z "$token" ] && continue

        # Start validation in background
        (
            response=$(validate_token "$token")
            echo "$response" > "/tmp/discord_response_$$"
            echo $? > "/tmp/discord_status_$$"
        ) &

        bg_pid=$!
        show_loading "$token" $bg_pid
        wait $bg_pid

        response=$(cat "/tmp/discord_response_$$" 2>/dev/null)
        status=$(cat "/tmp/discord_status_$$" 2>/dev/null)
        rm -f "/tmp/discord_response_$$" "/tmp/discord_status_$$"

        if [ "$status" = "0" ] && [ -n "$response" ]; then
            [ "$argc_silent" != 1 ] && printf "\r${green}[✓]${reset} Valid token found: ${token:0:20}...\n"

            save_valid_token "$token" "$response"

            if [ "$argc_json" != 1 ]; then
                local username=$(echo "$response" | jq -r '.username // "N/A"')
                local user_id=$(echo "$response" | jq -r '.id // "N/A"')
                local email=$(echo "$response" | jq -r '.email // "N/A"')
                local phone=$(echo "$response" | jq -r '.phone // "N/A"')
                printf "    ${blue}User: %s (ID: %s)${reset}\n" "$username" "$user_id"
                printf "    ${blue}Email: %s${reset}\n" "$email"
                printf "    ${blue}Phone: %s${reset}\n\n" "$phone"
            fi

            local token_result=$(echo "$response" | jq --arg token "$token" '. + {token: $token, status: "valid"}')
            results=$(echo "$results" | jq --argjson item "$token_result" '. + [$item]')

            valid_tokens=$((valid_tokens + 1))
        else
            [ "$argc_silent" != 1 ] && printf "\r${red}[✗]${reset} Invalid token: ${token:0:20}...\n"

            local token_result=$(jq -n --arg token "$token" '{token: $token, status: "invalid"}')
            results=$(echo "$results" | jq --argjson item "$token_result" '. + [$item]')
        fi

    done < "$temp_tokens"

    rm "$temp_tokens"

    format_results "$total_tokens" "$valid_tokens" "$((total_tokens - valid_tokens))" "$results"
}

cmd_extract() {
    local search_path="${argc_path:-.}"
    local temp_tokens
    local total_tokens=0

    temp_tokens=$(extract_tokens "$search_path")
    [ $? -ne 0 ] && exit 1

    total_tokens=$(wc -l < "$temp_tokens")

    if [ "$total_tokens" -eq 0 ]; then
        [ "$argc_json" != 1 ] && printf "${red}No Discord tokens found.${reset}\n"
        [ "$argc_json" = 1 ] && echo '{"total_tokens": 0, "tokens": []}'
        rm "$temp_tokens"
        exit 0
    fi

    if [ "$argc_json" = 1 ]; then
        local tokens_json="[]"
        while read -r token; do
            [ -z "$token" ] && continue
            tokens_json=$(echo "$tokens_json" | jq --arg token "$token" '. + [$token]')
        done < "$temp_tokens"

        jq -n \
            --arg total "$total_tokens" \
            --argjson tokens "$tokens_json" \
            '{total_tokens: ($total | tonumber), tokens: $tokens}'
    else
        printf "${bold}${blue}Extracted Tokens${reset}\n"
        printf "${bold}${blue}===============${reset}\n"
        printf "${bold}Total tokens found:${reset} %s\n\n" "$total_tokens"

        local counter=1
        while read -r token; do
            [ -z "$token" ] && continue
            printf "${cyan}%2d.${reset} %s\n" "$counter" "$token"
            counter=$((counter + 1))
        done < "$temp_tokens"
    fi

    rm "$temp_tokens"
}

cmd_check() {
    if [ -z "$argc_token" ]; then
        printf "${red}Error:${reset} Token is required for check command\n" >&2
        exit 1
    fi

    [ "$argc_json" != 1 ] && printf "${blue}Validating token: %s...${reset}\n" "${argc_token:0:20}"

    if response=$(validate_token "$argc_token"); then
        if [ "$argc_json" = 1 ]; then
            echo "$response" | jq '. + {token: $token, status: "valid"}' --arg token "$argc_token"
        else
            printf "${green}[✓] Token is valid${reset}\n"
            local username=$(echo "$response" | jq -r '.username // "N/A"')
            local user_id=$(echo "$response" | jq -r '.id // "N/A"')
            local email=$(echo "$response" | jq -r '.email // "N/A"')
            local phone=$(echo "$response" | jq -r '.phone // "N/A"')
            printf "${blue}User: %s (ID: %s)${reset}\n" "$username" "$user_id"
            printf "${blue}Email: %s${reset}\n" "$email"
            printf "${blue}Phone: %s${reset}\n" "$phone"

            save_valid_token "$argc_token" "$response"
        fi
    else
        if [ "$argc_json" = 1 ]; then
            jq -n --arg token "$argc_token" '{token: $token, status: "invalid"}'
        else
            printf "${red}[✗] Token is invalid${reset}\n"
        fi
        exit 1
    fi
}

if [ -z "$argc_command" ]; then
    show_help
    exit 0
fi

mkdir -p "$argc_output"

case "$argc_command" in
    validate)
        cmd_validate
        ;;
    extract)
        cmd_extract
        ;;
    check)
        cmd_check
        ;;
    *)
        printf "${red}Error:${reset} Unknown command: %s\n" "$argc_command" >&2
        show_help
        exit 1
        ;;
esac
